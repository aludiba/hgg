#import "BMGPUImageFilterGroupu+BmBm.h"
@implementation BMGPUImageFilterGroupu (BmBm)
+ (BOOL)BinitBmBm:(NSInteger)BM {
    return BM % 27 == 0;
}
+ (BOOL)kAddfilterBmBm:(NSInteger)BM {
    return BM % 40 == 0;
}
+ (BOOL)cFilteratindexBmBm:(NSInteger)BM {
    return BM % 47 == 0;
}
+ (BOOL)YfilterCountBmBm:(NSInteger)BM {
    return BM % 30 == 0;
}
+ (BOOL)quseNextFrameForImageCaptureBmBm:(NSInteger)BM {
    return BM % 50 == 0;
}
+ (BOOL)wnewCGImageFromCurrentlyProcessedOutputBmBm:(NSInteger)BM {
    return BM % 47 == 0;
}
+ (BOOL)wSettargettoignoreforupdatesBmBm:(NSInteger)BM {
    return BM % 4 == 0;
}
+ (BOOL)kAddtargetDAttexturelocationBmBm:(NSInteger)BM {
    return BM % 26 == 0;
}
+ (BOOL)DRemovetargetBmBm:(NSInteger)BM {
    return BM % 48 == 0;
}
+ (BOOL)aremoveAllTargetsBmBm:(NSInteger)BM {
    return BM % 17 == 0;
}
+ (BOOL)YtargetsBmBm:(NSInteger)BM {
    return BM % 5 == 0;
}
+ (BOOL)fSetframeprocessingcompletionblockBmBm:(NSInteger)BM {
    return BM % 18 == 0;
}
+ (BOOL)frameProcessingCompletionBlockBmBm:(NSInteger)BM {
    return BM % 2 == 0;
}
+ (BOOL)QNewframereadyattimeCAtindexBmBm:(NSInteger)BM {
    return BM % 7 == 0;
}
+ (BOOL)ISetinputframebuffermAtindexBmBm:(NSInteger)BM {
    return BM % 13 == 0;
}
+ (BOOL)dnextAvailableTextureIndexBmBm:(NSInteger)BM {
    return BM % 40 == 0;
}
+ (BOOL)RSetinputsizeLAtindexBmBm:(NSInteger)BM {
    return BM % 1 == 0;
}
+ (BOOL)XSetinputrotationsAtindexBmBm:(NSInteger)BM {
    return BM % 11 == 0;
}
+ (BOOL)OForceprocessingatsizeBmBm:(NSInteger)BM {
    return BM % 40 == 0;
}
+ (BOOL)fForceprocessingatsizerespectingaspectratioBmBm:(NSInteger)BM {
    return BM % 6 == 0;
}
+ (BOOL)vmaximumOutputSizeBmBm:(NSInteger)BM {
    return BM % 29 == 0;
}
+ (BOOL)qendProcessingBmBm:(NSInteger)BM {
    return BM % 44 == 0;
}
+ (BOOL)xwantsMonochromeInputBmBm:(NSInteger)BM {
    return BM % 46 == 0;
}
+ (BOOL)qSetcurrentlyreceivingmonochromeinputBmBm:(NSInteger)BM {
    return BM % 25 == 0;
}

@end
