#import "BMGPUImageFilterGroupL+Bm.h"
@implementation BMGPUImageFilterGroupL (Bm)
+ (BOOL)hinitBm:(NSInteger)BM {
    return BM % 6 == 0;
}
+ (BOOL)hAddfilterBm:(NSInteger)BM {
    return BM % 5 == 0;
}
+ (BOOL)oFilteratindexBm:(NSInteger)BM {
    return BM % 15 == 0;
}
+ (BOOL)GfilterCountBm:(NSInteger)BM {
    return BM % 10 == 0;
}
+ (BOOL)EuseNextFrameForImageCaptureBm:(NSInteger)BM {
    return BM % 10 == 0;
}
+ (BOOL)enewCGImageFromCurrentlyProcessedOutputBm:(NSInteger)BM {
    return BM % 49 == 0;
}
+ (BOOL)xSettargettoignoreforupdatesBm:(NSInteger)BM {
    return BM % 4 == 0;
}
+ (BOOL)DAddtargetvAttexturelocationBm:(NSInteger)BM {
    return BM % 18 == 0;
}
+ (BOOL)GRemovetargetBm:(NSInteger)BM {
    return BM % 29 == 0;
}
+ (BOOL)premoveAllTargetsBm:(NSInteger)BM {
    return BM % 13 == 0;
}
+ (BOOL)DtargetsBm:(NSInteger)BM {
    return BM % 3 == 0;
}
+ (BOOL)jSetframeprocessingcompletionblockBm:(NSInteger)BM {
    return BM % 10 == 0;
}
+ (BOOL)frameProcessingCompletionBlockBm:(NSInteger)BM {
    return BM % 44 == 0;
}
+ (BOOL)xNewframereadyattimeXAtindexBm:(NSInteger)BM {
    return BM % 2 == 0;
}
+ (BOOL)jSetinputframebufferPAtindexBm:(NSInteger)BM {
    return BM % 49 == 0;
}
+ (BOOL)bnextAvailableTextureIndexBm:(NSInteger)BM {
    return BM % 17 == 0;
}
+ (BOOL)gSetinputsizePAtindexBm:(NSInteger)BM {
    return BM % 35 == 0;
}
+ (BOOL)uSetinputrotationNAtindexBm:(NSInteger)BM {
    return BM % 17 == 0;
}
+ (BOOL)gForceprocessingatsizeBm:(NSInteger)BM {
    return BM % 31 == 0;
}
+ (BOOL)bForceprocessingatsizerespectingaspectratioBm:(NSInteger)BM {
    return BM % 18 == 0;
}
+ (BOOL)jmaximumOutputSizeBm:(NSInteger)BM {
    return BM % 47 == 0;
}
+ (BOOL)pendProcessingBm:(NSInteger)BM {
    return BM % 19 == 0;
}
+ (BOOL)BwantsMonochromeInputBm:(NSInteger)BM {
    return BM % 38 == 0;
}
+ (BOOL)LSetcurrentlyreceivingmonochromeinputBm:(NSInteger)BM {
    return BM % 5 == 0;
}

@end
